================================================================================
8 Index - 많은 데이터 관리하기(빠른 읽기)

================================================================================
데이터가 많아지면서 느려지는 탐색시간

n+1 문제 -> populate 개선 -> nesting 개선.

1. 데이터가 많아지면 느려질수 밖에 없다.
그래서, 인덱스 보기. 

================================================================================
Index 원리 이해하기

1. 기존 검색은 전부 풀 스캔으로 다 찾아야 한다.
반면에, 인덱스를 사전식 또는 오름차순등으로 정렬 해놓은 것으로 
검색을 하고, 그 결과를 가지고 검색을 하면 , 검색 속도가 훨씬 더 빠름. 
ch8_index_ex1,ex2 이미지 참고. 

================================================================================
탐색 성능 테스트를 위한 데이터 생성

1. 기존 BlogService2 디비 삭제 후. 
2. server.js 에서 faker 로 샘플 디비 생성.
3. faker3 으로 작업.  
4. mongoose.set('debug', true) 주석. 
5. 10만으로 테스트 하기. 

================================================================================
index 성능 테스트하기

1. 콤파스에서 인덱스 탭 들어가기. 
2. 성능 결과 분석 해주는 탭 -> Explain Plan 
3. {age: 30} 으로 검색.
샘플로 , 결과 보면 COLLSCAN 에서 nReturned : 1992 개 확인. 
Documents 탭에서도 같은 결과 갯수 확인 됨. 

인덱스 설정 전
인덱스가 설정이 안되어서 풀 스캔으로 
Documents Examined : 100000 모두 검사. 
약 5 ms 정도 걸리고, 그리 오래 안걸렸음. 

Actual Query Execution Time (ms):42

4. 인덱스 탭에서 
인덱스 추가해보기. 
Create Index -> Index fields : age 선택, 1(asc) 선택. -> Create Index
만약, 유니크 설정 하고 싶으면, 옵션에서 선택하기. : Create unique index

5. 인덱스 추가 후 , 다시 성능 테스트 
2번으로 가서 다시 실행. 3번 진행. 
결과 
Actual Query Execution Time (ms):3
그리고, 풀스캔에서 IXSCAN(인덱스 스캔으로)
문서 검사 건수도 : 딱 1992 개만 했음(전에는 10만개 다했음. )

현재로는 성능 차이는 없음. 

6. 다시 성능 테스트를 위해서, 추가한 인덱스 삭제. 

7. 
2번 성능 결과 분석 해주는 탭 -> Explain Plan 
3번 {age: {$gte: 20}} 으로 검색.
정렬을 추가하기. 
옵션 추가하기 : {age:1}
(Documents에서 검색시 데이터 많아서 : skip 항목에서 숫자를 입력하면 해당 항목 만큼 넘어감. )
결과
Actual Query Execution Time (ms):98
Documents Examined:100000
Documents Returned:79934
COLLSCAN 했음. 
검색 결과 볼때, VISUAL TREE 로 보기. 
정렬은 오래 걸림. 

그래서, 검색 조건의 나이를 60으로 변경하면 결과가 빨리 나옴. 
반대로. 0 으로 하면 오래 걸림. 

이제 인덱스 걸고 , 확인 해보기. 
3번 {age: {$gte: 20}} 으로 검색.
4번으로 진행. 
5번 진행. 
결과. 
Actual Query Execution Time (ms):98
Documents Returned:79934
Documents Examined:79934


인덱스를 하고나서 , 항상 FETCH를 함. 
인덱스 없을 때는, 컬렉션 전체를 스캔 하지만, 
인덱스 있을 때는, 정렬된 컬렉션에서 스캔을 함. (FETCH)

8.
오름차순 인덱스 삭제 후, 내림차순으로 인덱스 추가 후  테스트 해보기. 
비슷하게 나옴. 
검색 조건에서 오름 차순으로 설정 후, 정렬. 이것도 비슷함. 
단일키로 오름차순, 내림차순 상관 없음. 
만약, 복합키로 설정하면 순서가 중요함. 



================================================================================
Pagination 원리

1. skip, limit 
검색시, skip, limit 사용시 속도 빠름. 

2. skip : 300, limit : 300 
검색시 
IXSCAN 에서 600 개 읽고, 
SKIP 에서 300개 읽기. 
시작 부분, 끝 부분 검색 속도가 빠르고, 
중간 부분 느리다. 
중간 부분 속도 개선 방법이 있지만, 여기 과정에 다루지 않음. 
나중에 필요하면 검색해서 해당 기능 추가 해놓기. 


================================================================================
GET /blog API에 Pagination 적용

1.  포스트맨으로 
blog -> get api 로 
에서 Params 에서 보내고 싶은 변수 설정해서 보내는 방법. 
ex)
http://localhost:3000/blog?page=0&sort=1

2. 기존 페이커 데이터 삭제 후, faker2 으로 디비 만들고
확인 하기. 나눠서 만들기. 

3. blogRoute.js 작업. 
테스트 한번. 
http://localhost:3000/blog?page=0
확인 됨. 

4. 
express 가 해주는 건데, 확인 하기. page 
   let { page } = req.query;
    console.log({ page });
추가 후, 포스트맨으로 확인 콘솔 확인 page 0 

5. 
결과 값이 문자열로 나와서, 정수로 parse 하기. 
page = parseInt(page)
포스트맨으로 확인 콘솔 확인 page 0 , 이제 숫자로 넘어옴. 

6. 
한 페이지에 3개씩, 0페이지 부터, 정렬 변경 날짜 내림차순(최신날짜.)
let blogs = await Blog.find({}).sort({ updatedAt: -1}).skip(page * 3).limit(3);
포스트맨으로 확인 , 결과 숫자 부분 클릭해서, blogs 안에 3개 만 괄호 된 부분 확인 가능. 

7.
오름차순으로 변경해서 확인 가능. 



================================================================================
Compound Key(복합키)
정렬을 여러개로 하고 싶을 때

샘플 데이터 유저만 10만개로 만들기. 
faker3 으로 
await generateFakeData(100000, 5, 20);
인덱스, age 1 로 추가. 

1.  콤파스로 {age:1} 검색 해보기. 

2. {age:1, username:1} 2개의 조건으로 검색. 

3. {age:1, username:-1} 2개의 조건으로 검색. 

4. {username:1, age:1} 2개의 조건으로 검색. 

오래 걸림. Explain Plan 으로 확인시, 컬렉션 스캔으로 하고 있음. 

5. 복합 인덱스 만들기. (플러스 기호로 추가 하기. )
age 1, username 1 , 둘다 1로 
	
COMPOUND 키가 생성됨. 용량도 조금 많음. 

6. 
다시 {age:1, username:1} 2개의 조건으로 검색. 
이제 인덱스 적용이 됨. 
limit 걸어 주면 더 빨라짐. 
주의1)
만약 순서를 다르게해서 하면 의미가 없음. 똑같이 컬렉션 스캔이 됨.
그래서, 순서 주의하기. 
만약, 순서 변경해서 사용할려면, 복합키 하나 더 생성해야 함. 

주의2)
그리고 정렬 조건을 변경시 또 인덱스 적용이 안됨 .
단일 키이면 상관없지만, 대칭이라서, 
복합 키이면 순서가 상관이 있어서, 정렬도 맞춰주어야 함. 
만약, 정렬 변경해서 사용할려면, 복합키 하나 더 생성해야 함. 

7. 
복합키 추가시, 
age :1 , username :-1 추가 하고, 
검색시 
{  age:-1, username:1} 
이렇게해도 잘 검색이 됨. 



================================================================================
Selectivity - 분포도를 고려해서 효율적으로 인덱스 생성

1. 콤파스에서 ,Documents 로 검색 
ex) 
{"name.last":"Ledner"}

2. 검색. 
{age : 30}

3. {"name.last":"Ledner", age : 30} 2가지로 검색 해서 결과 갯수 보기. 6개 나옴. 예시로.

4. 성능 테스트로 확인. 
Explain Plan 

5. 인덱스 추가. 
name.last 1 

6. 4번 수행. 

7. 결과 확인시. 
VISUAL TREE 말고, RAW JSON 으로 보면, 
2가지 있음. 
(1) winningPlan  Object

(2) rejectedPlans  Array

어떤 인덱스가 더 효과적인지 몽고 디비가 모름. 
그래서, 몇개의 샘플로 검색을 해서, 더 빠른 검색을 선택을하고, 아닌건 거절함. 
사실은 인덱스 스캔이 하나 더 있지만, 성능상 안좋아서 버림. 
만약, 해당 조건의 복합키가 있다면, 우선순위는 복합키가 더 높음. 

8. Selectivity 
인덱스 추가. 
name.last 1, age 1 

확인. 
인덱스가 없다면, 기존 몽고디비가 샘플로 확인 작업을 하고 결정 하므로 느림. 
그러나, 복합키로 인덱스 추가로 검사를 하게되면 빨라짐. 



================================================================================
mongoose로 index 생성하기

================================================================================
text index 생성하기

================================================================================
세션 마무리
